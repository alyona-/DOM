

<public:attach event="oncontentready" onevent="oncontentready('v08vnSVo78t4JfjH')" />
<script type="text/javascript">

// findPos() borrowed from http://www.quirksmode.org/js/findpos.html
function findPos(obj) {  /*Функция поиска позиции элемента*/
	var curleft = curtop = 0; /*Относительно верхней точки*/

	if (obj.offsetParent) { /*
Браузер  позиционирует элементы относительно друг друга,
 и у каждого элемента есть свой "родитель по позиционированию": offsetParent.
   в качестве родителя будет выступать родитель parentNode, но если элемент с позиционированием absolute,
   то будет выбираться ближайший позиционный родитель
	*/
	
	    /*Цикл выполнится 1 раз в любом случае и будет выполняться до тех пор - пока 
		  obj не будет равен obj.OffserParent*/
		do {
		/*В каждой итерации к каждому значению суммируется его значение*/
			curleft += obj.offsetLeft;  
			curtop += obj.offsetTop;  /*Получает текущие значения отступов относительно документа для первого элемента в наборе.*/
		} while (obj = obj.offsetParent); /*Получает текущие значения отступов относительно родителя  элемента в наборе.*/
	}
       /*Цикл, который будет выполняться пока значение отступов элемента не будет равно значению отступов родителя*/
	return({
		'x': curleft,  /*Возвращает в конечном итоге --*/
		'y': curtop
	});
}

function oncontentready(classID) {
  if (this.className.match(classID)) { return(false); } /*Если текущий класс равен - ID возвращаю false*/

	if (!document.namespaces.v) { document.namespaces.add("v", "urn:schemas-microsoft-com:vml"); }

	this.className = this.className.concat(' ', classID); /*Присваивается имени класса текущее значение переменной строку объединение' ' и classID*/
	var arcSize = Math.min(parseInt(this.currentStyle['-moz-border-radius'] ||
	                                this.currentStyle['-webkit-border-radius'] ||   /*Преобразуется значение в строку, затем с помощью метода
									                                                  Match.min - находится минимальное значение, оно присваивается в 
																					           переменную arcSize*/
	                                this.currentStyle['border-radius'] ||
	                                this.currentStyle['-khtml-border-radius']) / 
	                       Math.min(this.offsetWidth, this.offsetHeight), 1);
						   
	var fillColor = this.currentStyle.backgroundColor; /*currentStyle -Возвращает цвет фона который задан в CSS*/
	var fillSrc = this.currentStyle.backgroundImage.replace(/^url\("(.+)"\)$/, '$1'); /*currentStyle -возвращает адрес картинки с заменой символов

	*/
	var strokeColor = this.currentStyle.borderColor; /*Присваивается цвет границы*/
	var strokeWeight = parseInt(this.currentStyle.borderWidth); /*strokeWeight  присваивается ширина бордера текущего объекта, преобразованная в строку*/
	var stroked = 'true'; 
	if (isNaN(strokeWeight)) {
		strokeWeight = 0;
		strokeColor = fillColor;
		stroked = 'false';
	}

	this.style.background = 'transparent';
	this.style.borderColor = 'transparent';

	
	
	/*Находится какой элемент обеспечивает положение относительно целевого элемента, по умолчанию используется BODY*/
	var el = this; /*Объявляется текущий элемент*/
	var limit = 100, i = 0;
	while ((typeof(el) != 'unknown') && (el.currentStyle.position != 'relative') && (el.tagName != 'BODY')) {
	/*Принцип в том, что если позиция элемента relative - то используется родительская нода, если положение абсолютное, тогда
	ближайшая родительская нода с абсолютным позиционированием*/
		el = el.parentElement;
		i++;
		if (i >= limit) { return(false); } /*Возвращается false - когда i -  будет равна 100*/
	}
	var el_zindex = parseInt(el.currentStyle.zIndex);
	if (isNaN(el_zindex)) { el_zindex = 0; } /*Если не задан z-index , тогда z-index присваивается значение 0*/
	//alert('got tag '+ el.tagName +' with pos '+ el.currentStyle.position); /*тут видимо автор тестировал код*/

	
	/*Объект прямоугольник, в этой части присваиваются свойствам объекта значения, которые были полученны в 
	верхней части*/
	var rect_size = {
		'width': this.offsetWidth - strokeWeight, /*Текущая величина -  */
		'height': this.offsetHeight - strokeWeight
	};
	var el_pos = findPos(el); /*Передается текущий объект в функцию поиска позиции элемента,
	    полученное значение из отработанной функции присваивается в переменную el_pos*/
	var this_pos = findPos(this); /**/
	
	/*Математической правило округления -вариант округления к ближайшему целому элементу*/
	this_pos.y = this_pos.y + (0.5 * strokeWeight) - el_pos.y;
	this_pos.x = this_pos.x + (0.5 * strokeWeight) - el_pos.x;

	var rect = document.createElement('v:roundrect'); /*Создает VML элемент v:roundrect*/
	rect.arcsize = arcSize +'px'; /**/
	rect.strokecolor = strokeColor;
	rect.strokeWeight = strokeWeight +'px';
	rect.stroked = stroked;
	/*Задаются стили*/
	rect.style.display = 'block';
	rect.style.position = 'absolute';
	
	/*rect - в W3C - используется для создания прямоугольника, параметры x,y,weight, height*/
	rect.style.top = this_pos.y +'px'; /*Склеивание строк x,y,weight,height с 'px'*/
	rect.style.left = this_pos.x +'px';
	rect.style.width = rect_size.width +'px';
	rect.style.height = rect_size.height +'px';
	rect.style.antialias = true;
	rect.style.zIndex = el_zindex - 1; /*Присваивается z-index меньший на 1,чем z-index элемента*/

	var fill = document.createElement('v:fill'); /*Создается элемент fill   - v:fill - это создание динамического VML элемента-
	расширяет традиционный статический html элемент*/
	fill.color = fillColor;
	fill.src = fillSrc;
	fill.type = 'tile';

	rect.appendChild(fill);  /*rect присваивает дочерний элемент fill*/
	el.appendChild(rect); /el присваивает дочерний элемент rect*/

	var css = el.document.createStyleSheet(); /*Создается новая таблица стилей*/
	css.addRule("v\\:roundrect", "behavior: url(#default#VML)");
	css.addRule("v\\:fill", "behavior: url(#default#VML)");

	isIE6 = /msie|MSIE 6/.test(navigator.userAgent); /*Узнается название браузера пользователя*/
	// IE6 doesn't support transparent borders, use padding to offset original element
	if (isIE6 && (strokeWeight > 0)) { /*Код, который работает для IE 6 верссии*/
		this.style.borderStyle = 'none'; /*Текущий стиль границы скрывает*/
		this.style.paddingTop = parseInt(this.currentStyle.paddingTop || 0) + strokeWeight; /*Текущее значение padding-TOP элемента или
		0 + strokeWeight - все это преобразуется в число и присваивается к значение padding-TOp текущего объекта*/
		
		/*Те же действия проделываются для padding-bottom*/
		this.style.paddingBottom = parseInt(this.currentStyle.paddingBottom || 0) + strokeWeight;
	}

	if (typeof(window.rounded_elements) == 'undefined') {  /*Если значение  window.rounded_elements - будет равно undefined*/
		window.rounded_elements = new Array(); /*то присваиваем новый массив*/

		if (typeof(window.onresize) == 'function') { window.previous_onresize = window.onresize; }
		window.onresize = window_resize; /*при изменениии размера = присваиваю размер*/
	}
	this.element.vml = rect; /*Тут присваивается функция rect, которая создает прямоугольник
      в качетсве параметров берет x,y,weight,height
	*/
	window.rounded_elements.push(this.element);
}

function window_resize() {   /*Функция изменения размера окна -- это когда пользователь смотрит не во весь размер окна*/
	if (typeof(window.rounded_elements) == 'undefined') { return(false); } /*Если размер окна неопределен, то возвращается false*/

	for (var i in window.rounded_elements) { /*Передаю в массив размер window.rounded_elements*/
		var el = window.rounded_elements[i];
        /*В массиве осуществляется перебор размера окна*/
		var strokeWeight = parseInt(el.currentStyle.borderWidth); /*Преобразуется  в число размер ширины границы полученный из таблицы
		                                                            стилей*/
		if (isNaN(strokeWeight)) { strokeWeight = 0; }  /*Если параметр можно преобразовать в число, то StrokeWeight присваивается 0*/

		var parent_pos = findPos(el.vml.parentNode); /*Вызываю функцию поиска позиции в неё передается родительский элемент el*/
		var pos = findPos(el); /*Передается сам элемент в функцию поиска позиции*/
		pos.y = pos.y + (0.5 * strokeWeight) - parent_pos.y; /*Математической правило округления -вариант округления к ближайшему целому элементу*/
		pos.x = pos.x + (0.5 * strokeWeight) - parent_pos.x;

		el.vml.style.top = pos.y +'px'; /*Расположение относительно верха экрана*/
		el.vml.style.left = pos.x +'px'; /*Расположение от 0 точки слева*/
	}

	if (typeof(window.previous_onresize) == 'function') { window.previous_onresize(); }
}
</script>